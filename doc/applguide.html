<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <title>LinPac External Application Programming Guide</title>
</head>
<body>

<h1><center>LinPac - Packet Radio Terminal for Linux</center></h1>
<hr>
<center>
<p>Version 0.27</p>
<p>
(c) Martin Cooper KD6YAM 2020<br>
(c) David Ranch KI6ZHD (linpac@trinnet.net) 2002 - 2016<br>
(c) 1998 - 2001 by Radek Burget OK2JBG
</p>
</center>

<h2><center>External Application Programming Guide</center></h2>

<b>Contents</b>
<p>1 <a href="#POS1">Introduction</a>
<p>2 <a href="#POS2">What is an external program?</a>
<p>3 <a href="#POS3">Basic concepts of the API</a>
<p>4 <a href="#POS4">How applications communicate with LinPac</a>
<p>5 <a href="#POS5">Using the application library</a>
<br>5.1 <a href="#POS5_1">The simplest application</a>
<p>6 <a href="#POS6">Application programming</a>
<br>6.1 <a href="#POS6_1">Events</a>
<br>6.2 <a href="#POS6_2">Sending and receiving events</a>
<br>6.3 <a href="#POS6_3">Synchronization</a>
<br>6.4 <a href="#POS6_4">Shared variables and configuration</a>
<br>6.5 <a href="#POS6_5">Connection status</a>
<br>6.6 <a href="#POS6_6">Event usage examples</a>
<br>6.6.1 <a href="#POS6_6_1">Connecting to a remote station</a>
<br>6.6.2 <a href="#POS6_6_2">Using LinPac commands in programs</a>
<p>7 <a href="#POS7">The application library interface</a>
<br>7.1 <a href="#POS7_1">Constants</a>
<br>7.2 <a href="#POS7_2">Data structures</a>
<br>7.3 <a href="#POS7_3">Functions</a>
<br>7.3.1 <a href="#POS7_3_1">Uninterruptable versions of some system calls</a>
<br>7.3.2 <a href="#POS7_3_2">Basic communication functions</a>
<br>7.3.3 <a href="#POS7_3_3">Automatic event handling functions</a>
<br>7.3.4 <a href="#POS7_3_4">Environment functions</a>
<br>7.3.5 <a href="#POS7_3_5">User functions</a>
<br>7.3.6 <a href="#POS7_3_6">Tool functions</a>
<br>7.3.7 <a href="#POS7_3_7">Application information functions</a>
<p>8 <a href="#POS8">The shell interface</a>
<br>8.1 <a href="#POS8_1">Writing the script</a>
<br>8.1.1 <a href="#POS8_1_1">Ensuring that LinPac is running</a>
<br>8.1.2 <a href="#POS8_1_2">Accessing configuration and state</a>
<br>8.1.3 <a href="#POS8_1_3">Executing commands</a>
<br>8.1.4 <a href="#POS8_1_4">Simple shell example</a>
<br>8.2 <a href="#POS8_2">Creating the command</a>

<p><a NAME="POS1"></a>
<h2>1 Introduction</h2>
This guide is written for programmers who want to add some new functions
to LinPac. In the following text, basic knowledge of Linux programming
is assumed. Reading the LinPac User Manual before proceeding is also
recommended.

<p><a NAME="POS2"></a>
<h2>2 What is an external program?</h2>
An external program is a standard Linux application which uses LinPac to
communicate with remote stations. There are basically two types of LinPac
external programs:
<ul>
<li>
Standard Linux applications that use standard input and output streams.
These programs can be used without LinPac too. LinPac allows redirection
of the input stream (stdin) of the application and any of the output streams
(stdout, stderr) or both of them. LinPac can also provide CR/LF conversions
in these streams. These parameters are set when adding the external program
to LinPac - see <a href="manual.html#POS7">Section 7</a>, "Creating
new commands", in the User Manual.</li>

<li>
Applications written using LinPac's application interface. These applications
can share some information with LinPac, and they can control almost all
functions of LinPac.</li>
</ul>
No special knowledge of LinPac is needed for creating the first type
of programs, because no LinPac functions are used. The remainder of
this guide is dedicated to the second type of applications.

<p><a NAME="POS3"></a>
<h2>3 Basic concepts of the API</h2>
The LinPac application interface is based on <em>events</em>. Every action
in LinPac, such as pressing a key, receiving data, executing a command,
etc., is represented by a data structure called an <em>event</em>, which describes
exactly what happened. LinPac's internal structure consists of separate
<em>objects</em> which
communicate with each other using these events. Each object provides its
own functionality, and often generates events. For example, the object
<code>Keyscan</code> produces an event each time any key is pressed.
<p>All the events generated by any object are put into the common <em>event
queue</em>. The LinPac kernel simply takes the events from the queue one by
one and sends them to all the objects (including the one that generated
the event). Thus <strong>each event generated by any part of LinPac is forwarded
to all of the objects</strong>. The reaction of each object fully depends on its
functionality, but of course it can include generation of other events.
<p>The list of LinPac internal objects and their names can be found in
the file <a href="objects.txt">objects.txt</a>.
<p>An additional feature of the API is a shared variable environment. This
is a set of variables that is shared with LinPac; the values are automatically
synchronized with all the external programs. These variables are accessed
using special functions of the API as described below.

<p><a NAME="POS4"></a>
<h2>4 How applications communicate with LinPac</h2>
LinPac uses TCP/IP sockets for communication with external
programs (applications). The connection is always initiated by the application
after it starts. There are basically two ways that an application may be started:
<ul>
<li>
The application is started by LinPac, through being associated with a LinPac command.
In this case LinPac registers the channel on which the application was started
and expects the connection attempt from the application. After the application
initializes and contacts LinPac, it is provided with the working channel and whether
it was started by a remote or local user. LinPac may also redirect the input
and output streams of the application (depending upon LinPac settings).</li>

<li>
The application is started without using LinPac. In this case LinPac assumes
that the application runs on channel 0 and was started by the local user. The
input and output streams of the application are not redirected.</li>
</ul>
In both cases, the start of an application causes the creation of a new
object in LinPac called an <em>event gate</em>. This object represents the application
within LinPac. Bearing in mind the previous chapter, this means that the application
is forwarded all of the events generated by any LinPac object, and all of the
events generated by the application are forwarded to all LinPac objects.
<p><strong>NOTE:</strong> All of the communication via TCP/IP sockets is provided by
the LinPac application library. The user application should not attempt to access the
sockets directly.

<p><a NAME="POS5"></a>
<h2>
5 Using the application library</h2>
During LinPac installation, the application library <code>liblinpac</code> is
created and installed by default to <code>/usr/local/lib</code>. The interface
to this library is contained in the file <code>lpapp.h</code>, which is installed
by default to <code>/usr/local/include/linpac</code>. The next chapter
illustrates how to use the library within a user application.

<p><a NAME="POS5_1"></a>
<h3>5.1 The simplest application</h3>
The following application example just tries to contact LinPac, and prints the
result.

<pre><code>
---------------------------- File test1.c ---------------------------
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;linpac/lpapp.h&gt;

int main()
{
    if (lp_start_appl())
    {
        printf("Application started\n");
        sleep(10);
        printf("Application finished\n");
        lp_end_appl();
    }
    else
    {
        printf("LinPac is not running\n");
        return 1;
    }
    return 0;
}
---------------------------------------------------------------------
</code></pre>

<p>The function <code>lp_start_appl()</code> tries to contact LinPac and returns
<strong>1</strong>
in case of success or <strong>0</strong> when a connection to LinPac cannot be made (probably
because it's not running). This function should precede the usage of any other
application library functions.
<p>The function <code>lp_end_appl()</code> closes the connection to LinPac.
<p>To compile this example, use:
<p><code>$ gcc -o test1 test1.c -llinpac</code>
<p>This example just detects if LinPac is running, and it can be executed
directly from the shell. When running from the shell, no streams are redirected
to LinPac, and the application appears to run on channel 0 of LinPac. This is
useful for some applications that are used to control LinPac from outside.
However this is not a typical use case.
<p>For most applications, it is better to copy the executable to the
<code>$LINPACDIR/bin</code>
directory and then add it to the file
<code>$LINPACDIR/bin/commands</code> as described in the <a href="manual.html">User
Manual</a>. After this, the application can be executed as a LinPac command.
In this scenario, the streams are properly redirected and the application output
is visible in the LinPac QSO window. It is also possible to select the channel
on which to run the application.
<p><strong>NOTE:</strong> The LinPac application library (<code>liblinpac</code>) can be
linked without problems with both C and C++ code.

<p><a NAME="POS6"></a>
<h2>6 Application programming</h2>

<a NAME="POS6_1"></a>
<h3>6.1 Events</h3>
LinPac is completely driven by events. Each part of LinPac, including
applications, can generate events to inform other parts (internal modules
or applications) that something has happened. Each event is sent to all
LinPac components and applications. For example when some station connects
to some LinPac channel, the internal AX.25 interface generates an event
reporting that the station has connected and includes its callsign. All
components and applications now know who has connected, and they can take
some actions. For example, the output window prints information about the connection,
the macro processor executes the cinit.mac macro, and so on. Each application
can handle all of the events too, and can generate events which are handled
by other components.
<p>An event is represented by the following structure:
<pre><code>
struct Event
{
    int type;
    int chn;
    int x,y;
    char ch;
    void *data;
};
</code></pre>
<p>The meaning of each field is as follows:
<dl>
  <dt><code>type</code></dt>
  <dd>Specifies the type of the event. Actually it determines what happened.
  There is a symbolic constant defined for each known event type.</dd>
  <dt><code>chn</code></dt>
  <dd>Specifies the channel to which the event applies.
  For example, if the type of the event specifies that some data was received,
  the <code>chn</code> field contains the number of the channel which has
  received that data. There are many events that apply for all the channels. For
  those events, this field is not significant.</dd>
  <dt><code>x, y</code></dt>
  <dd>The meaning of these fields depends on the event type. The <code>y</code>
  field is usually not used, other than by some internal events.</dd>
  <dt><code>ch</code></dt>
  <dd>This field is used only by some internal events.</dd>
  <dt><code>data</code></dt>
  <dd>Depends on the type of the event. It usually points to some string data
  or a char buffer.</dd>
</dl>
<p>All of the event types are described in the <a href="events.txt">event
list</a>.

<p><a NAME="POS6_2"></a>
<h3>6.2 Sending and receiving events</h3>
For sending events the following function is used:
<p><code>int lp_emit_event(int chn, int type, int x, void *data);</code>
<p>This generates a new event using the specified values. Each argument
corresponds to one of the fields in the <code>Event</code> structure.
<p>There are two modes for handling incoming events:
<p><strong><em>a) Reading each event on demand</em></strong>
<p>This mode is started by the <code>lp_event_handling_off()</code> call.
In this mode, events are read explicitly using the function:
<p><code>int get_event(Event *ev);</code>
<p>This function returns <strong>0</strong> when no event is available. When an
event is available, it returns <strong>1</strong> and fills the <code>Event</code>
structure with the received event data.
<p><strong>WARNING #1:</strong> The <code>data</code> field in your <code>Event</code> structure must
point to a dynamically allocated buffer. The size of the buffer is reallocated
automatically after receiving an event. When the <code>data</code> field is
set to <code>NULL</code>, a new buffer is allocated. This field <em>must be initialized</em>.
<p><strong>WARNING #2:</strong> In this mode, the application <em>must</em> read all events.
It is not a good idea to stop reading events, because the event
queue may overflow. LinPac will automatically kill the application when the
event queue exceeds some reasonable number of events.
<p><strong><em>b) Automatic event processing</em></strong>
<p>This mode is started by the <code>lp_event_handling_on()</code> call. All
events are read automatically. Programmers can define their own function
that will be called automatically when an event occurs. When no such
function is defined, all events are discarded.
<p>The event handling function must have following prototype:
<p><code>void my_event_handler(Event *ev);</code>
<p>(The function name may be different.) After initializing the application,
the event handling function must be registered using the function:
<p><code>lp_set_event_handler()</code>
<p>from the application library.
<p>The following example is an application that prints the types of all events
received and stops when an <code>EV_ABORT</code> event is received. This event
can be generated using the <code>:ABort</code> command in LinPac.

<pre><code>
---------------------------------------------------------------------------
#include &lt;stdio.h&gt;
#include &lt;linpac/lpapp.h&gt;

int aborted = 0;

//User event handling function. This function is called each time
//an event occurs
void my_event_handler(Event *ev)
{
    printf("The event of type %i has been received\n", ev->type);
    if (ev->type == EV_ABORT) aborted = 1;
}

int main()
{
    if (lp_start_appl())
    {
        lp_event_handling_on(); //turn on automatic event handling
        lp_set_event_handler(my_event_handler); //define own event handler

        printf("Application started\n");
        printf("Stop with the ':Abort' command\n");

        do ; while(!aborted); //wait until application is aborted

        printf("Application finished\n");
        lp_end_appl();
    }
    else
    {
        printf("LinPac is not running\n");
        return 1;
    }

    return 0;
}
---------------------------------------------------------------------------
</code></pre>

<p>This example contains "active waiting" (the <code>do ; while(...)</code>
construction). This is very ugly and inefficient. For this reason, the LinPac API offers an
alternative for waiting for events, namely the <code>lp_wait_event()</code> function.
Let's change the example to use this function:

<pre><code>
---------------------------------------------------------------------------
#include &lt;stdio.h&gt;
#include &lt;linpac/lpapp.h&gt;

int main()
{
    if (lp_start_appl())
    {
        lp_event_handling_on(); //turn on automatic event handling

        printf("Application started\n");
        printf("Stop with the ':Abort' command\n");

        lp_wait_event(lp_channel(), EV_ABORT); //wait for the abort event

        printf("Application finished\n");
        lp_end_appl();
    }
    else
    {
        printf("LinPac is not running\n");
        return 1;
    }

    return 0;
}
----------------------------------------------------------------------------
</code></pre>

<p><strong>WARNING:</strong> Note that some system calls may be interrupted when
an event is received. An interrupted system call returns an error result (for
example the <code>read()</code> call returns -1), sets <code>errno</code> to
<code>EAGAIN</code>, and must be called again. To avoid this, use the interrupt-safe
versions of the system calls contained in this application library. (See
<a href="#POS7_3_1">Chapter 7.3.1</a>.)

<p><a NAME="POS6_3"></a>
<h3>6.3 Synchronization</h3>
An event generated by an application is sent to all modules and applications,
including the application that generated the event. When there is a
need to wait until the event is accepted by LinPac, the simplest way is
to wait until the event we have sent is received back.
<p>For testing that all events were processed, there is an <code>EV_VOID</code> event.
It is not handled by any module. After sending all events, just generate
an <code>EV_VOID</code> event and wait until it returns. After that, you can be
assured that all previous events have been processed.

<p><a NAME="POS6_4"></a>
<h3>6.4 Shared variables and configuration</h3>
Each shared variable is denoted by its name (string) and channel number. Each
variable has a value represented by a string (char[]). Access to
these variables is provided by following functions:
<dl>
  <dt><code>void lp_set_var(int chn, const char *name, const char *value)</code></dt>
  <dd>Changes the value of the variable. If the variable doesn't exist, it
  is created.</dd>
  <dt><code>char *lp_get_var(int chn, const char *name)</code></dt>
  <dd>Reads the value of the variable. Returns NULL if the variable doesn't
  exist.</dd>
  <dt><code>void lp_del_var(int chn, const char *name)</code></dt>
  <dd>Deletes the variable.</dd>
  <dt><code>void lp_clear_var_names(int chn, const char *prefix)</code></dt>
  <dd>Deletes all variables with the specified name.</dd>
</dl>
<p>The value of each variable is automatically synchronized with LinPac
and all running applications. The variables whose names start with "_"
are reserved for system use. These variables can be used for obtaining
system configuration and status but it may be potentialy dangerous to change
some of these variables.
<p><strong>NOTE:</strong> Many of the variables contain boolean values. Their
value is <strong>1</strong> when true, <strong>0</strong> otherwise.
<p>Currently the following system variables are defined (in channel 0):

<dl>
  <dt><code>_remote</code></dt>
  <dd>1 when remote commands are enabled</dd>
</dl>
<dl>
  <dt><code>_cbell</code></dt>
  <dd>1 when connect sound is enabled</dd>
  <dt><code>_knax</code></dt>
  <dd>1 when sound signal for each frame is enabled</dd>
</dl>
<dl>
  <dt><code>_def_port</code></dt>
  <dd>default port name</dd>
  <dt><code>_unportname</code></dt>
  <dd>port name for unproto frames</dd>
  <dt><code>_unport</code></dt>
  <dd>port number for unproto frames</dd>
</dl>
<dl>
  <dt><code>_info_level</code></dt>
  <dd>status-line level (0 to 2)</dd>
  <dt><code>_no_name</code></dt>
  <dd>default station name</dd>
  <dt><code>_timezone</code></dt>
  <dd>local timezone name</dd>
  <dt><code>_swap_edit</code></dt>
  <dd>1 when swapedit is on</dd>
  <dt><code>_fixpath</code></dt>
  <dd>1 when fixpath is on</dd>
  <dt><code>_daemon</code></dt>
  <dd>1 when linpac works as a daemon</dd>
  <dt><code>_monitor</code></dt>
  <dd>1 when monitor is enabled</dd>
  <dt><code>_no_monitor</code></dt>
  <dd>1 when monitor is disabled from command line</dd>
  <dt><code>_listen</code></dt>
  <dd>1 when accepting connections is enabled</dd>
  <dt><code>_disable_spyd</code></dt>
  <dd>1 when ax25spyd support is disabled from command line</dd>
  <dt><code>_mon_bin</code></dt>
  <dd>1 when monitor filters binary characters</dd>
  <dt><code>_monparms</code></dt>
  <dd>command line arguments for 'listen' program</dd>
  <dt><code>_maxchn</code></dt>
  <dd>maximal number of channels</dd>
  <dt><code>_last_act</code></dt>
  <dd>time of last user activity (same format as the time() system call).</dd>
</dl>

<p>These variables may be read using the <code>lp_get_var()</code> function defined
above. Furthermore there are two special functions defined for reading
these variables. These functions expect the name of the system variable
<em>without</em> the leading underscore.

<dl>
  <dt><code>char *lp_sconfig(const char *name)</code></dt>
  <dd>Returns the value of the configuration variable as a string.</dd>
  <dt><code>int lp_iconfig(const char *name)</code></dt>
  <dd>Returns the value of the configuration variable as an integer.</dd>
</dl>

<p>The following system variables are defined for each channel:

<dl>
  <dt><code>_call</code></dt>
  <dd>callsign for each channel</dd>
  <dt><code>_cwit</code></dt>
  <dd>connected with callsign</dd>
  <dt><code>_cphy</code></dt>
  <dd>physical connection to</dd>
  <dt><code>_port</code></dt>
  <dd>connected on which port</dd>
  <dt><code>_state</code></dt>
  <dd>connection status</dd>
</dl>

<p>There are also special functions for reading values of these variables:

<dl>
  <dt><code>int lp_chn_status(int chn)</code></dt>
  <dd>Returns the status of a channel. The following status constants are defined:
    <dl>
      <dt><code>ST_DISC</code></dt>
      <dd>channel disconnected</dd>
      <dt><code>ST_DISP</code></dt>
      <dd>disconnect in progress</dd>
      <dt><code>ST_TIME</code></dt>
      <dd>disconnecting for timeout</dd>
      <dt><code>ST_CONN</code></dt>
      <dd>channel connected</dd>
      <dt><code>ST_CONP</code></dt>
      <dd>connecting in progress</dd>
    </dl>
  </dd>
  <dt><code>char *lp_chn_call(int chn)</code></dt>
  <dd>Returns channel callsign.</dd>
  <dt><code>char *lp_chn_cwit(int chn)</code></dt>
  <dd>Returns the callsign of connected station.</dd>
  <dt><code>char *lp_chn_cphy(int chn)</code></dt>
  <dd>Returns the callsign of physicaly connected station (the first connected station).</dd>
  <dt><code>int lp_chn_port(int chn)</code></dt>
  <dd>Returns the number of the port used for connection.</dd>
</dl>

<p>The last two functions enable changing the time of last users's response:

<dl>
  <dt><code>time_t lp_last_activity()</code></dt>
  <dd>Returns the time of last activity of the user.</dd>
  <dt><code>void lp_set_last_activity(time_t timeval)</code></dt>
  <dd>Sets the last activity time.</dd>
</dl>

<p><a NAME="POS6_5"></a>
<h3>6.5 Connection status</h3>
There are two special events reserved for obtaining the AX.25 connection
status. When an application wants to get the status of the connection
on a certain LinPac channel, it generates the <code>EV_STAT_REQ</code> event on this channel.
In response, LinPac generates the <code>EV_STATUS</code> event. The <code>data</code> field
of this event points to the <code>ax25_status</code> structure (see <a href="#POS7_2">Chapter
7.2</a>). When there is no active connection on the channel, no <code>EV_STATUS</code>
event is generated.

<p><a NAME="POS6_6"></a>
<h3>6.6 Event usage examples</h3>
The following examples show how to use events for controlling LinPac. The
complete list of events can be found in the file <a href="events.txt">events.txt</a>.

<p><a NAME="POS6_6_1"></a>
<h4>6.6.1 Connecting to a remote station</h4>
When initiating the connection, the first step is to check that the channel
is free (i.e. it is not in use for another connection). The status of a channel
can be checked using the <code>lp_chn_status()</code> function (see
<a href="#POS6_4">Chapter 6.4</a>).
<p>The second step is emiting the <code>EV_CONN_LOC</code> event on the appropriate
channel. The <code>data</code> field of the event contains a C string with
the destination address in the form <code>port:callsign [digi [digi ...]]</code>.
<p>The last step is to wait until the connection is established. For this
the function <code>lp_wait_connect()</code> can be used. An example piece of
code follows:

<pre><code>
---------------------------------------------------------------------
int chn = lp_channel();
if (lp_chn_status(chn) == ST_DISC)
{
    char addr[30];
    strcpy(addr, "kiss:OK0PAB OK0NMA");
    lp_emit_event(chn, EV_CONN_LOC, 0, addr);
    lp_wait_connect(chn, "OK0PAB");
    /* ... connection established ... */
}
---------------------------------------------------------------------
</code></pre>

<p><a NAME="POS6_6_2"></a>
<h4>6.6.2 Using LinPac commands in programs</h4>
Any application may run LinPac commands by emitting the <code>EV_DO_COMMAND</code>
event. For example, to download a message from a BBS using the <code>getmsg</code>
command following code can be used:

<pre><code>
---------------------------------------------------------------------
char cmd[30];
sprintf(cmd, "getmsg %i", message_number);
lp_emit_event(lp_channel(), EV_DO_COMMAND, 0, cmd);
---------------------------------------------------------------------
</code></pre>

<p>Another option is to use the <code>EV_WANT_RESULT</code> event. The usage
is similar to the previous example, but the <code>x</code> field of the event has
special meaning: as a response to this event, LinPac will generate an
<code>EV_CMD_RESULT</code> event
with the same <code>x</code> field and with the <code>data</code> field containing
the result of the command.
<p>An example follows:

<pre><code>
---------------------------------------------------------------------
char cmd[30];
int id = 0;
Event *ev;

sprintf(cmd, "getmsg %i", message_number);
lp_emit_event(lp_channel(), EV_WANT_RESULT, 1234, cmd);
while (id != 1234)  /* wait for the command result */
{
    lp_wait_event(lp_channel(), EV_CMD_RESULT);
    ev = lp_awaited_event();
    id = ev->x;
}
printf("The result is: %s\n", (char *)ev.data);
---------------------------------------------------------------------
</code></pre>

<p><a NAME="POS7"></a>
<h2>7 The application library interface</h2>
<a NAME="POS7_1"></a>
<h3>7.1 Constants</h3>

<dl>
  <dt><code>LPAPP_VERSION</code></dt>
  <dd>the version of LinPac that the library came with</dd>
  <dt><code>ST_xxxx</code></dt>
  <dd>connection status constants (see <a href="#POS6_4">Chapter 6.4</a>)</dd>
</dl>

<p><a NAME="POS7_2"></a>
<h3>7.2 Data structures</h3>

<dl>
  <dt><code>struct ax25_status</code></dt>
  <dd>contains the AX.25 connection status:</dd>
</dl>

<pre><code>
typedef struct
{
    char devname[8];
    int state;
    int vs, vr, va;
    int t1, t2, t3, t1max, t2max, t3max;
    int idle, idlemax;
    int n2, n2max;
    int rtt;
    int window;
    int paclen;
    bool dama;
    int sendq, recvq;
} ax25_status;
</code></pre>

<p><a NAME="POS7_3"></a>
<h3>7.3 Functions</h3>
<a NAME="POS7_3_1"></a>
<h4>7.3.1 Uninterruptable versions of some system calls</h4>
<p>The following functions work the same way as the original system calls, but
they are interrupt-safe. That is, they don't fail with <code>errno == EAGAIN</code>.

<dl>
  <dt><code>size_t safe_read(int fd, void *buf, size_t count);</code></dt>
  <dt><code>size_t safe_write(int fd, const void *buf, size_t count);</code></dt>
  <dt><code>char *safe_fgets(char *s, int size, FILE *stream);</code></dt>
  <dt><code>int safe_fgetc(FILE *stream);</code></dt>
</dl>

<p><a NAME="POS7_3_2"></a>
<h4>7.3.2 Basic communication functions</h4>

<dl>
  <dt><code>int lp_start_appl()</code></dt>
  <dd>Starts communication with LinPac. A non-zero return value means success; a
  zero value means that LinPac cannot be contacted (probably because it's not
  running).</dd>
  <dt><code>int lp_get_event(Event *ev)</code></dt>
  <dd>Read an event from the queue. A non-zero return value means a successful
  read; a zero value means that the event queue is empty. The <code>data</code>
  field of the event structure <em>must</em> be initialized before using this
  function (to NULL or to some buffer). This function should not be used when
  automatic event processing is used.</dd>
  <dt><code>int lp_emit_event(int chn, int type, int x, void *data)</code></dt>
  <dd>Generate a new event. The arguments correspond to the fields in the
  event structure. The return value is always 0.</dd>
  <dt><code>void lp_wait_event(int chn, int type)</code></dt>
  <dd>Wait until an event with the same <code>chn</code> and <code>type</code>
  values are received.</dd>
  <dt><code>void lp_wait_init(int chn, int type)</code></dt>
  <dd>The same as <code>lp_wait_event()</code> but returns immediately. Waiting
  is provided by following function <code>lp_wait_realize()</code>.</dd>
  <dt><code>void lp_wait_realize()</code></dt>
  <dd>Realizes waiting initialized by <code>lp_wait_init()</code>. All the events
  that arrived since the last <code>lp_wait_init()</code> call are ignored.
  <code>lp_wait_realize()</code> may exit immediately if the event has already
  arrived.</dd>
  <dt><code>Event *lp_awaited_event()</code></dt>
  <dd>After return from a call to <code>lp_wait_event()</code> or
  <code>lp_wait_realize()</code>, this function returns the event that stopped
  the waiting.</dd>
  <dt><code>Event *lp_copy_event(Event *dest, const Event *src)</code></dt>
  <dd>Copy the event structure (using a deep copy).</dd>
  <dt><code>void lp_discard_event(Event *ev)</code></dt>
  <dd>Free the memory used by the data field of Event structure received
  using <code>lp_get_event()</code>.</dd>
  <dt><code>void lp_clear_event_queue()</code></dt>
  <dd>Remove all events from the event queue. This has no purpose when automatic
  event processing is enabled.</dd>
  <dt><code>void lp_end_appl()</code></dt>
  <dd>Closes the connection to LinPac.</dd>
</dl>

<p><a NAME="POS7_3_3"></a>
<h4>7.3.3 Automatic event handling functions</h4>

<dl>
  <dt><code>void lp_event_handling_on()</code></dt>
  <dd>Enables automatic event handling. From this point onwards, each event
  is automatically read from the queue, treated with an event handler function
  (if defined) and then discarded.</dd>
  <dt><code>void lp_event_handling_off()</code></dt>
  <dd>Disables automatic event handling. Events must be read from the queue
  using the <code>lp_get_event()</code> function.</dd>
  <dt><code>void lp_set_event_handler(handler_type handler)</code></dt>
  <dd>Defines the event handler function, a function with signature
  <code>void my_event_handler(Event *ev)</code>. The event handler is
  called automatically each time an event is received, when automatic event
  handling is enabled.</dd>
</dl>

<p><a NAME="POS7_3_4"></a>
<h4>7.3.4 Environment functions</h4>
LinPac has its own environment for storing variables. Each application
can share and modify this environment using environment-related functions. Each
channel has its own environment. See <a href="#POS6_4">Chapter 6.4</a> for a
detailed description and list of functions.

<p><a NAME="POS7_3_5"></a>
<h4>7.3.5 User functions</h4>

<dl>
  <dt><code>void lp_appl_result(const char *fmt, ...)</code></dt>
  <dd>Set the final result of the application. This function generates an
  <code>EV_APP_RESULT</code> event with the specified message string. The
  argument format is the same as for <code>printf()</code>.</dd>
  <dt><code>void lp_statline(const char *fmt, ...)</code></dt>
  <dd>Displays or changes the additional status line in the LinPac user
  interface. Only one additional status line is displayed. This function
  generates a <code>EV_CHANGE_STLINE</code> event with the <code>x</code> field
  (line ID) containing the PID of the application. To display more than one
  status line for the application, additional <code>EV_CHANGE_STLINE</code>
  events must be generated manually.</dd>
  <dt><code>void lp_remove_statline()</code></dt>
  <dd>Removes the additional status line.</dd>
  <dt><code>void lp_disable_screen()</code></dt>
  <dd>Disables displaying data in the QSO window on application's channel.
  The <code>EV_DISABLE_SCREEN</code> event is used to accomplish this.</dd>
  <dt><code>void lp_enable_screen()</code></dt>
  <dd>Enables displaying data in the QSO window. The <code>EV_ENABLE_SCREEN</code>
  event is used to accomplish this.</dd>
  <dt><code>void lp_wait_connect(int chn, const char *call)</code></dt>
  <dd>Waits for a connection with the specified callsign on the specified
  channel.</dd>
</dl>

<p><a NAME="POS7_3_6"></a>
<h4>7.3.6 Tool functions</h4>

<dl>
  <dt><code>char *time_stamp(int utc)</code></dt>
  <dd>Returns a pointer to a C string that contains the actual time. If
  <code>utc</code> is 0, then local time is used; otherwise UTC time is used.</dd>
  <dt><code>char *date_stamp(int utc)</code></dt>
  <dd>Returns the date-string.</dd>
  <dt><code>void replace_macros(int chn, char *s)</code></dt>
  <dd>Replaces macro variables in the string (i.e. <code>%xxx</code>) with their
  values. The <code>%(command)</code> macro is not replaced.</dd>
  <dt><code>void get_port_name(int n)</code></dt>
  <dd>Returns the name of the nth port in axports (starting from 0).</dd>
</dl>

<p><a NAME="POS7_3_7"></a>
<h4>7.3.7 Application information functions</h4>

<dl>
  <dt><code>char *lp_version()</code></dt>
  <dd>Returns the current LinPac version.</dd>
  <dt><code>int lp_channel()</code></dt>
  <dd>Returns the channel number on which the application was started. Returns
  0 when the application was not started using LinPac.</dd>
  <dt><code>int lp_app_remote()</code></dt>
  <dd>Returns a non-zero value if the application was started using a remote
  command in LinPac (i.e. the application is communicating with a remote user).</dd>
</dl>

<p><a NAME="POS8"></a>
<h2>8 The shell interface</h2>
In addition to the C API described in the above chapters, LinPac also provides
a set of functions that allow programmers to create new LinPac commands using
bash shell scripts. While this set of functions is limited, it is sufficient
to enable quite sophisticated and complex commands to be added to LinPac
without requiring programming in C or C++.

<p><a NAME="POS8_1"></a>
<h3>8.1 Writing the script</h3>

<p>The shell functions are all accessed through the <code>lpapi</code> command,
which has the following form:
<p><code>lpapi &lt;channel&gt; [command] [arguments]</code>
<p>The specifics of the available commands are described in the following sections.
<p>The channel on which the script application is running is made available to
the script as the <code>$LPCHN</code> shell environment variable. The use of
this variable is demonstrated below.

<p><a NAME="POS8_1_1"></a>
<h4>8.1.1 Ensuring that LinPac is running</h4>
The first step in any LinPac shell command should be to ensure that LinPac is
running, such that subsequent use of the shell interface can proceed. This is
accomplished by calling the API as follows:
<p><code>lpapi 0</code>
<p>This command will exit with a 0 result code if LinPac is running. Any other
result code indicates that LinPac is not running, in which case the script
should most likely echo an error message to the user and exit. As usual, the
result code can be determined by examining the special <code>$?</code> value.

<p><a NAME="POS8_1_2"></a>
<h4>8.1.2 Accessing configuration and state</h4>
It is important that a shell script be able to determine the current status of
LinPac and retrieve configuration values. The API provides several functions
to enable this.
<p>All of these functions return values that can be assigned to
a shell variable, and are used in the following manner (using "call" as an
example here):
<p><code>MYVAR=`lpapi $LPCHN call`</code>
<p>The available functions are as follows:
<dl>
  <dt><code>call</code></dt>
  <dd>Return the callsign for the specified channel.</dd>
  <dt><code>cwit</code></dt>
  <dd>Return the callsign of the station connected on the specified channel.</dd>
  <dt><code>port</code></dt>
  <dd>Return the port of the station connected on the specified channel.</dd>
  <dt><code>state</code></dt>
  <dd>Return current status of the specified channel (as a number).</dd>
  <dt><code>pname &lt;number&gt;</code></dt>
  <dd>Return the name of port with the specified number.</dd>
  <dt><code>get &lt;variable&gt;</code></dt>
  <dd>Return the value of specified variable on the specified channel.</dd>
</dl>

<p><a NAME="POS8_1_3"></a>
<h4>8.1.3 Executing commands</h4>
Accomplishing real work with the shell interface will usually require calling
into LinPac to execute other LinPac commands. This is achieved using the
<code>do</code> command, which is functionally equivalent to generating the
<code>EV_DO_COMMAND</code> event from the C API.
<p>The <code>do</code> command has the following form:
<p><code>lpapi &lt;channel&gt; do &lt;command&gt; [arguments]</code>
<p>However, since <code>do</code> is a reserved word in Bash shell scripts,
it is necessary to use Bash's <code>eval</code> command to invoke it as a
LinPac function, as follows:
<p><code>eval lpapi &lt;channel&gt; do "&lt;command&gt; [arguments]"</code>
<p><strong>IMPORTANT:</strong> The <code>do</code> command is asynchronous.
That is, the shell command may return before the command issued to LinPac has
completed. A script will need to account for this in considering subsequent
actions.

<p><a NAME="POS8_1_4"></a>
<h4>8.1.4 Simple shell example</h4>

TBD

<p><a NAME="POS8_2"></a>
<h3>8.2 Creating the command</h3>
The steps to add the script to LinPac as a new command are essentially the same
as for an application written in C, described in <a href="#POS5_1">Chapter 5.1</a>
above. That is:
<ol>
  <li>Copy the script to the <code>$LINPACDIR/bin</code> directory, making
  sure that the permissions allow execution.</li>
  <li>Add the new command to the file <code>$LINPACDIR/bin/commands</code> as
  described in the <a href="manual.html">User Manual</a>.</li>
</ol>

<hr>
<center>
<p><i><font size=-1>Last update: 16 Feb 2020</font></i>
</center>

</body>
</html>
